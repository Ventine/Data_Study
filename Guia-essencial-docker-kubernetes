# Guía Esencial: Docker y Kubernetes

**Propósito:** referencia técnica concisa y ejecutable sobre los conceptos, comandos y manifiestos esenciales de Docker y Kubernetes para uso en repositorios Git.

---

## Índice

1. Docker — conceptos y prácticas
2. Dockerfile — instrucciones clave
3. Multistage builds — patrón y ejemplos
4. Imágenes, tags y registries
5. Comandos útiles de Docker
6. Kubernetes — conceptos y arquitectura
7. Manifiestos esenciales (Pod, Deployment, Service, Ingress)
8. ConfigMaps, Secrets y Volúmenes
9. Namespaces, RBAC y políticas
10. Deploy, rollouts y debugging
11. CI/CD y GitOps con contenedores
12. Buenas prácticas y checklist breve

---

## 1. Docker — conceptos y prácticas

* Contenedor: proceso aislado con sistema de archivos efímero.
* Imagen: plantilla inmutable construida desde un Dockerfile.
* Runtime: ejecutor de imágenes (containerd, runc).
* Registro (Registry): almacenamiento de imágenes (Docker Hub, GitHub Container Registry, GCR, ECR).
* Principio: construir imágenes pequeñas, reproducibles y con un único propósito por contenedor.

---

## 2. Dockerfile — instrucciones clave

* `FROM <imagen>`: base.
* `WORKDIR /ruta`: directorio de trabajo.
* `COPY` / `ADD`: copiar archivos.
* `RUN`: comandos en tiempo de build.
* `ENV`: variables de entorno en la imagen.
* `EXPOSE <puerto>`: documentación del puerto.
* `USER`: ejecuta como usuario no-root.
* `CMD` vs `ENTRYPOINT`: comando por defecto (overridable) vs ejecutable fijo.

Ejemplo mínimo:

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY . .
EXPOSE 3000
USER node
CMD ["node", "index.js"]
```

---

## 3. Multistage builds — patrón y ejemplos

Objetivo: separar etapa de compilación de la de runtime para reducir tamaño y eliminar artefactos.

```dockerfile
# Build stage
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Runtime stage
FROM node:18-slim
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY package*.json ./
RUN npm ci --production
EXPOSE 3000
CMD ["node", "dist/index.js"]
```

Beneficios: menores superficies de ataque, imágenes más pequeñas, velocidad en despliegue.

---

## 4. Imágenes, tags y registries

* Etiqueta semántica: usar `app:1.2.3`, `app:1.2.3-rc.1`, `app:latest` (evitar `latest` en producción).
* Firmado y escaneo: habilitar firmas y escaneo de vulnerabilidades (Trivy, Clair).
* Caché: optimizar orden de capas para cachear dependencias.
* Retención: limpiar imágenes antiguas en el registry.

---

## 5. Comandos útiles de Docker

* `docker build -t repo/name:tag .`
* `docker run --rm -p 3000:3000 repo/name:tag`
* `docker ps`, `docker logs <container>`, `docker exec -it <container> /bin/sh`
* `docker push repo/name:tag`
* `docker image prune`, `docker system prune`

---

## 6. Kubernetes — conceptos y arquitectura

* Cluster: conjunto de nodos gestionados por control plane.
* Node: VM o máquina que ejecuta pods.
* Pod: unidad mínima; encapsula uno o varios contenedores que comparten red y volumenes.
* ReplicaSet / Deployment: aseguran número deseado de pods y manejan actualizaciones.
* Service: abstracción de red estable (ClusterIP, NodePort, LoadBalancer).
* Ingress: reglas de enrutamiento HTTP/HTTPS desde el exterior al cluster.
* Scheduler, Controller Manager, API Server, etcd: componentes del control plane.

---

## 7. Manifiestos esenciales

### Pod (no recomendado para producción, ejemplo didáctico)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app
    image: myrepo/app:1.0.0
    ports:
    - containerPort: 3000
```

### Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: web
        image: myrepo/app:1.0.0
        ports:
        - containerPort: 3000
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 10
```

### Service (LoadBalancer)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  type: LoadBalancer
  selector:
    app: web
  ports:
  - port: 80
    targetPort: 3000
```

### Ingress (GKE/NGINX compatible)

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ingress
spec:
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
  tls:
  - hosts:
    - myapp.example.com
    secretName: tls-secret
```

---

## 8. ConfigMaps, Secrets y Volúmenes

* `ConfigMap`: configuración no sensible inyectada como variables o archivos.
* `Secret`: datos sensibles (base64) — usar KMS o secretos externos para producción.
* Volúmenes: `emptyDir`, `hostPath`, `persistentVolumeClaim` (PVC) para almacenamiento persistente.

Ejemplo ConfigMap y Secret:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  LOG_LEVEL: info

---
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
stringData:
  DB_USER: user
  DB_PASS: pa$$w0rd
```

---

## 9. Namespaces, RBAC y políticas

* Namespaces: segmentación lógica de recursos (`dev`, `staging`, `prod`).
* RBAC: `Roles` y `RoleBindings` para aplicar principio de menor privilegio.
* NetworkPolicies: controlar tráfico entre pods.

Ejemplo RoleBinding mínimo:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: dev
subjects:
- kind: User
  name: pipeline-runner
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

---

## 10. Deploy, rollouts y debugging

* `kubectl apply -f deployment.yaml`
* `kubectl rollout status deployment/app-deployment`
* `kubectl rollout undo deployment/app-deployment` (rollback)
* `kubectl get pods -o wide`, `kubectl logs -f pod/<pod>`
* `kubectl exec -it pod/<pod> -- /bin/sh` para debugging interactivo
* Debugging de imagen: ejecutar localmente con Docker antes de desplegar.

---

## 11. CI/CD y GitOps con contenedores

* Pipeline típico:

  1. `git push` → CI build (Docker image, tests, scan).
  2. Push image a registry con tag semántico.
  3. Actualizar manifiesto en repo `infra/` (GitOps) o ejecutar `terraform`/`kubectl` desde pipeline.
  4. ArgoCD / Flux / GitLab/GitHub CI aplican cambios y sincronizan el cluster.
* Firma de imágenes y políticas de admisión (Admission Controllers, OPA/Gatekeeper).

---

## 12. Buenas prácticas y checklist breve

* Diseñar imágenes pequeñas y sin dependencias de desarrollo.
* No usar `latest` en producción.
* Usar multistage builds.
* Habilitar readiness y liveness probes.
* Separar ConfigMaps y Secrets; no almacenar credenciales en texto plano.
* Aplicar principio de menor privilegio en IAM/RBAC.
* Escaneo automático de imágenes y políticas de seguridad en CI.
* Versionar manifiestos y seguir GitOps como fuente de la verdad.
* Monitoreo y alertas: Prometheus, Alertmanager, Grafana, Logging centralizado.

---

## Referencia rápida de comandos

* Docker: `docker build -t repo/app:1.0 .`, `docker push repo/app:1.0`, `docker run --rm -p 3000:3000 repo/app:1.0`.
* Kubernetes: `kubectl apply -f .`, `kubectl get pods`, `kubectl logs -f`, `kubectl rollout status deployment/<name>`.

---

## Final

Archivo diseñado para colocarlo en un repo Git como `docs/Guia-Essencial-Docker-Kubernetes.md` o como README en un subdirectorio `containers/`.
