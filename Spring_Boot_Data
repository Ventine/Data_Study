# Microservicios y Observabilidad — Documento técnico

## Índice

1. Microservicios: principios y prácticas
2. Spring Boot avanzado: estructura, configuración y Actuator
3. Spring WebFlux: programación reactiva (Mono/Flux)
4. Resilience (Resilience4j): patrones de tolerancia a fallos
5. OAuth2 con Spring Security: flujos, configuración y JWT
6. Prometheus y Micrometer: métricas y exposición
7. Grafana: dashboards y alertas
8. Jaeger / OpenTelemetry: trazabilidad distribuida
9. Integración práctica: ejemplo mínimo completo
10. Buenas prácticas operativas y checklist de observabilidad

---

## 1. Microservicios: principios y prácticas

**Concepto**: Conjunto de servicios pequeños, desplegables e independientes, organizados por *bounded contexts*. Cada servicio gestiona su propio modelo de datos y contrato API.

**Principios importantes**:

* Independencia de despliegue y ciclo de vida.
* Contratos versionados (OpenAPI / semantic versioning en APIs).
* Comunicaciones: sincrónica (HTTP/REST, gRPC) o asincrónica (Kafka, RabbitMQ).
* Descentralización de datos: cada servicio su propia base de datos.
* Observabilidad desde el diseño: logs estructurados, métricas, trazas.

**Patrones arquitectónicos**:

* API Gateway (rutas, autenticación, agregación)
* Service Discovery (Eureka, Consul) o DNS+LB de k8s
* Circuit Breaker, Retry, Bulkhead
* Saga para transacciones distribuidas
* Sidecar pattern (observabilidad y proxies)

---

## 2. Spring Boot avanzado: estructura, configuración y Actuator

**Estructura típica**:

```
src/main/java
  /com/example/service
    Application.java
    controller/
    service/
    repository/
src/main/resources
  application.yml
  logback-spring.xml
```

**Perfiles y configuración**:

* `application.yml` con `spring.profiles.active`.
* Configuración externa: Spring Cloud Config, HashiCorp Vault.

**Actuator**: endpoints esenciales:

* `/actuator/health` (salud)
* `/actuator/metrics` (métricas)
* `/actuator/prometheus` (si Micrometer Prometheus)
* `/actuator/loggers`

**Ejemplo `application.yml` mínimo**:

```yaml
server:
  port: 8080
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics,loggers
  endpoint:
    health:
      show-details: when_authorized
```

**Logs estructurados**: `logback-spring.xml` con JSON encoder (p.ej. Logstash Logback Encoder) y MDC para `traceId`.

---

## 3. Spring WebFlux: programación reactiva (Mono/Flux)

**Modelo**: `Mono<T>` = 0..1 elementos, `Flux<T>` = 0..N. Basado en Project Reactor.

**Ventaja**: no bloqueante, mejor uso de hilos bajo alta concurrencia.

**Código: controlador WebFlux**:

```java
@RestController
@RequestMapping("/orders")
public class OrderController {
    private final OrderService service;
    public OrderController(OrderService service){ this.service = service; }

    @GetMapping("/{id}
")
    public Mono<ResponseEntity<Order>> get(@PathVariable String id) {
        return service.findById(id)
            .map(order -> ResponseEntity.ok(order))
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @PostMapping
    public Mono<ResponseEntity<Order>> create(@RequestBody Mono<Order> body) {
        return body.flatMap(service::create)
                   .map(saved -> ResponseEntity.status(HttpStatus.CREATED).body(saved));
    }
}
```

**Punto crítico**: evitar llamadas bloqueantes (jdbc tradicional, restTemplate) dentro de rutas reactivas. Si es inevitable, aislar con `Schedulers.boundedElastic()`.

---

## 4. Resilience (Resilience4j)

**Componentes**:

* `CircuitBreaker` (abierto/cerrado/half-open)
* `Retry` con backoff
* `Bulkhead` (concurrency/thread pool)
* `TimeLimiter`
* `RateLimiter`

**Integración con Spring**: dependencia `io.github.resilience4j:resilience4j-spring-boot3`.

**Ejemplo declarativo (anotaciones)**:

```java
@Service
public class PaymentClient {

  @Retry(name = "paymentRetry")
  @CircuitBreaker(name = "paymentCb", fallbackMethod = "fallback")
  public Mono<PaymentResponse> pay(PaymentRequest req) {
    return webClient.post().uri("/pay").bodyValue(req).retrieve().bodyToMono(PaymentResponse.class);
  }

  public Mono<PaymentResponse> fallback(PaymentRequest req, Throwable t) {
    return Mono.just(new PaymentResponse("fallback", false));
  }
}
```

**Configuración `application.yml`**:

```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentCb:
        register-health-indicator: true
        slidingWindowSize: 50
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
  retry:
    instances:
      paymentRetry:
        maxAttempts: 3
        waitDuration: 500ms
        exponentialBackoff:
          enabled: true
```

**Métricas**: expuestas por Micrometer (`resilience4j.circuitbreaker.calls`, etc.).

---

## 5. OAuth2 con Spring Security: flujos, configuración y JWT

**Roles principales**:

* Authorization Server: emite tokens JWT (Keycloak, Auth0, Okta)
* Resource Server: microservicio que valida tokens
* Client: aplicación que obtiene token

**Flujos relevantes**:

* Client Credentials: microservicios -> microservicio (sin usuario)
* Authorization Code: usuario humano y frontend

**Resource Server (JWT) configuración mínima**:

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: https://auth.example.com/.well-known/jwks.json
```

**Spring Security Java config (resource server)**:

```java
@EnableWebSecurity
public class SecurityConfig {
  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
      .authorizeHttpRequests(auth -> auth
          .requestMatchers("/actuator/health", "/actuator/prometheus").permitAll()
          .anyRequest().authenticated())
      .oauth2ResourceServer(oauth2 -> oauth2.jwt());
    return http.build();
  }
}
```

**Validación de scopes y roles**: usar `@PreAuthorize("hasAuthority('SCOPE_orders:write')")` o `hasRole('ADMIN')`.

---

## 6. Prometheus y Micrometer: métricas y exposición

**Micrometer**: fachada para instrumentación (compatible con Prometheus, Datadog, NewRelic).

**Dependencia**: `io.micrometer:micrometer-registry-prometheus`.

**Exposición**: endpoint `/actuator/prometheus`.

**Métricas importantes**:

* `jvm.memory.used`, `jvm.gc.pause` (JVM)
* `process.cpu.*`
* `http.server.requests` (latencia, status, uri)
* `resilience4j.*`

**Ejemplo de métrica personalizada**:

```java
@Component
public class OrderMetrics {
  private final Counter created;
  public OrderMetrics(MeterRegistry registry) {
    created = Counter.builder("orders_created_total").description("Total de órdenes creadas").register(registry);
  }
  public void increment() { created.increment(); }
}
```

**Prometheus scrape config (prometheus.yml)**:

```yaml
scrape_configs:
  - job_name: 'orders-service'
    static_configs:
      - targets: ['orders-service:8080']
    metrics_path: /actuator/prometheus
```

---

## 7. Grafana: dashboards y alertas

**Dashboards**: diseñar paneles para latencia (p50/p95/p99), tasa de errores, throughput, saturación (threads, CPU, memory), health checks.

**Alertas**: definidas en Grafana (alert rules) o en Prometheus Alertmanager. Ejemplo regla:

```
alert: HighErrorRate
expr: sum(rate(http_server_requests_seconds_count{status=~"5.."}[5m])) / sum(rate(http_server_requests_seconds_count[5m])) > 0.05
for: 5m
```

**SLIs/SLOs**:

* SLI: request success rate, p99 latency
* SLO: 99.9% availability over 30 days

---

## 8. Jaeger / OpenTelemetry: trazabilidad distribuida

**Conceptos**: traceId atraviesa servicios; spans representan segmentos de trabajo.

**Instrumentación**: usar OpenTelemetry SDK + auto-instrumentation o `opentelemetry-spring-boot-starter`.

**Exporters**: Jaeger, OTLP/gRPC, Zipkin.

**Ejemplo de configuración (OTel -> Jaeger)** in `application.yml`:

```yaml
otel:
  exporter:
    otlp:
      endpoint: http://jaeger-collector:4317
```

**Correlación logs-trazas**: inyectar traceId en MDC para que aparezca en logs JSON.

```java
Span current = Span.current();
MDC.put("traceId", current.getSpanContext().getTraceId());
```

**Visualización**: Jaeger UI muestra spans y tiempos por servicio, detectar hotspots y latencias por hop.

---

## 9. Integración práctica: ejemplo mínimo completo

**Escenario**: `orders-service` (WebFlux), expone API, protegido por JWT, exporta métricas, tracea hacia Jaeger y aplica Resilience4j para llamadas a `payments-service`.

**Dependencias (build.gradle)**:

```groovy
implementation 'org.springframework.boot:spring-boot-starter-webflux'
implementation 'org.springframework.boot:spring-boot-starter-actuator'
implementation 'io.micrometer:micrometer-registry-prometheus'
implementation 'io.github.resilience4j:resilience4j-spring-boot3'
implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
implementation 'io.opentelemetry:opentelemetry-exporter-otlp'
```

**Controller sencillo**:

```java
@RestController
@RequestMapping("/orders")
public class OrderController {
  private final OrderService service;
  private final OrderMetrics metrics;
  public OrderController(OrderService service, OrderMetrics metrics){ this.service = service; this.metrics = metrics; }

  @PostMapping
  public Mono<ResponseEntity<Order>> create(@RequestBody Mono<Order> body) {
    return body.flatMap(service::create)
               .doOnNext(o -> metrics.increment())
               .map(o -> ResponseEntity.status(HttpStatus.CREATED).body(o));
  }
}
```

**Service con WebClient + Resilience4j**:

```java
@Service
public class PaymentService {
  private final WebClient client;
  public PaymentService(WebClient.Builder builder) { this.client = builder.baseUrl("http://payments").build(); }

  @CircuitBreaker(name = "paymentCb", fallbackMethod = "payFallback")
  @Retry(name = "paymentRetry")
  public Mono<PaymentResponse> pay(PaymentRequest req) {
    return client.post().uri("/pay").bodyValue(req).retrieve().bodyToMono(PaymentResponse.class);
  }

  public Mono<PaymentResponse> payFallback(PaymentRequest req, Throwable t){
    return Mono.just(new PaymentResponse("fallback", false));
  }
}
```

**OpenTelemetry**: habilitar auto-instrumentation en Docker image o con starter y configurar OTLP endpoint.

**Prometheus**: scrape `orders-service:8080/actuator/prometheus`.

**Jaeger**: verify traces arrive and correlate with logs.

---

## 10. Buenas prácticas operativas y checklist de observabilidad

* Instrumentar en el código: métricas (Counters/Timers/Gauges), eventos (logs) y trazas (spans).
* Exponer `/health` y comprobar dependencias (db, messaging).
* Correlación logs-trazas con `traceId` y `spanId` en MDC.
* Monitorear p50/p95/p99, no solo p90.
* SLIs claros y SLOs medibles.
* Alertas accionables y con runbooks vinculados.
* Pruebas de resiliencia: chaos testing (p.ej. Gremlin, Litmus)
* Seguridad: validar tokens JWT, limitar exposición de actuator.
* Despliegue: readiness/liveness probes, recursos (requests/limits), autoscaling basado en métricas relevantes.

---

### Anexos: comandos útiles

* Ver trazas Jaeger: `kubectl port-forward svc/jaeger 16686:16686`
* Ver métricas Prometheus: `kubectl port-forward svc/prometheus 9090:9090`
* Generar carga: `k6 run script.js` o `gatling`.

---

Fin del documento.
